return(liktot)
}
optim.out1=optim(par=cur_par[c(1,2,6,7)],g1,control=list(maxit=1000))
cur_par[c(1,2,6,7)]=optim.out1$par
if(incl_rho){
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],cur_par[5],cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
if(i==1){
cursleepest = GetIndSleepEstimates(dat,cur_par)
wt1=min(c(1,1-(30-nrow(cursleepest))/30))
cur_par[5]= max(0,wt1*cor(cursleepest[,1:2])[1,2])
}
}else{
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],0,cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
}
cat("Iter ",i,": mu_s =",cur_par[1],"; mu_w =",cur_par[2],"; sd_s =",cur_par[3],"; sd_w =",cur_par[4],"; rho =",cur_par[5],"; lambda_s =",cur_par[6],"; lambda_w =",cur_par[7],"\n")
if(sum((prev_par-cur_par)^2)<tol){
break
}else{
prev_par=cur_par
}
}
return(cur_par)
}
mle.out=FindParamMLEs(outmat_mod,anchor_t)
sleep_t_h=floor(mle.out[1]%%24)
sleep_t_m=floor((mle.out[1]%%24-floor(mle.out[1]%%24))*60)
if(sleep_t_m<10){
sleep_t=paste(sleep_t_h,":0",sleep_t_m,sep="")
}else{
sleep_t=paste(sleep_t_h,":",sleep_t_m,sep="")
}
wake_t_h=floor(mle.out[2]%%24)
wake_t_m=floor((mle.out[2]%%24-floor(mle.out[2]%%24))*60)
if(wake_t_m<10){
wake_t=paste(wake_t_h,":0",wake_t_m,sep="")
}else{
wake_t=paste(wake_t_h,":",wake_t_m,sep="")
}
cat(paste(" Avg. time to sleep = ",sleep_t," (+/- ",round(mle.out[3],1)," hour)\n",sep="")
,(paste("Avg. time to wake  = ",wake_t," (+/- ",round(mle.out[4],1)," hour)\n",sep=""))
,(paste("Correlation between time to sleep and time to wake = ",round(mle.out[5],2),"\n",sep=""))
,(paste("Rate (per hour) of frequency of phone use while asleep = ", round(mle.out[6],5),"\n",sep=""))
,(paste("Rate (per hour) of frequency of phone use while awake = ", round(mle.out[7],5),"\n",sep="")))
xest=GetIndSleepEstimates(outmat_mod,mle.out)
xest_orig=Mod2Orig(xest,d0,format="%m/%d/%Y %H:%M:%S")
names(xest_orig)=c("bedtime","wake-up time")
xest_orig
dat=outmat_mod
dat
anchor_t
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
mu_s0
mu_w0
lambda_s0
head(dat)
dat=matrix(c( 14.72611, 14.73694,1,14.87444,14.87694,1),ncol=3)
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
cat("Identifying good initial model parameters...\n")
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
incl_rho=TRUE
maxiter=20
tol=.0001
init_par = GridSearchInitPars(dat,anchor_t,labels,ls_ids,mu_s0,mu_w0,lambda_s0,lambda_w0,incl_rho)
init_par
dat
dat=matrix(c( 14.72611, 14.73694,1,14.87444,14.87694,1),ncol=3,byrow=T)
dat
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
mu_s0
mu_w0
lambda_s0
lambda_w0
init_par = GridSearchInitPars(dat,anchor_t,labels,ls_ids,mu_s0,mu_w0,lambda_s0,lambda_w0,incl_rho)
mat_mod=mat
mat_mod=dat
sd_s_v = c(.25,.5,1)
sd_w_v = c(.25,.5,1)
if(incl_rho){
rho_v= c(0,.25,.5,.75)
}else{
rho_v=c(0)
}
g=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=mat_mod[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,par_v[1],par_v[2],par_v[3],par_v[4],par_v[5],par_v[6],par_v[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(par_v[2]-par_v[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
minval=Inf
for(sd_s in sd_s_v){
for(sd_w in sd_w_v){
for(rho in rho_v){
par_v=c(mu_s0,mu_w0,sd_s,sd_w,rho,lambda_s0,lambda_w0)
curval=g(par_v)
if(curval<minval){
cur_par=par_v
minval=curval
}
}
}
}
sd_s
sd_w
rho
par_v
g(par_v)
par_v
liktot=0
for(i in 1:length(labels)){
mat=mat_mod[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,par_v[1],par_v[2],par_v[3],par_v[4],par_v[5],par_v[6],par_v[7],incl_rho))
}
liktot
length(labels)
liktot=0
mat=mat_mod[ls_ids[[i]],1:2]
mat
MargLik(mat,par_v[1],par_v[2],par_v[3],par_v[4],par_v[5],par_v[6],par_v[7],incl_rho)
if( mu_s> mu_w || sigma_s<0 || sigma_w<0 || abs(rho)>1 || lambda_s<0 || lambda_w <0 || lambda_s > lambda_w){
if(loglik){
return(-Inf)
} else{
return(0)
}
}
mu_s=par_v[1]
mu_w=par_v[2]
sigma_s=par_v[3]
sigma_w=par_v[4]
rho=par_v[5]
lambda_s=par_v[6]
lambda_w=par_v[7]
if( mu_s> mu_w || sigma_s<0 || sigma_w<0 || abs(rho)>1 || lambda_s<0 || lambda_w <0 || lambda_s > lambda_w){
if(loglik){
return(-Inf)
} else{
return(0)
}
}
mu_s> mu_w || sigma_s<0 || sigma_w<0 || abs(rho)>1 || lambda_s<0 || lambda_w <0 || lambda_s > lambda_w
if(is.null(nrow(mat)) || nrow(mat)==0){
if(loglik){
return(0)
}else{
return(1)
}
}
is.null(nrow(mat)) || nrow(mat)==0
incl_rho
Sigma=matrix(c(sigma_s^2,rho*sigma_s*sigma_w,rho*sigma_s*sigma_w,sigma_w^2),nrow=2,byrow=T)
Sigma
ghout=mgauss.hermite(n=3,c(mu_s,mu_w),Sigma) # n=points is the number of quadrature points per dimesion
sum(ghout$weights*unlist(lapply(1:nrow(ghout$points),function(xx) JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho))))
loglik=FALSE
sum(ghout$weights*unlist(lapply(1:nrow(ghout$points),function(xx) JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho))))
ghout$weights*unlist(lapply(1:nrow(ghout$points),function(xx) JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho)))
ghout$weights
unlist(lapply(1:nrow(ghout$points),function(xx) JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho))
)
xx=1
JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho)
JointLik(mat,mu_s,mu_w,sigma_s,sigma_w,rho,lambda_s,lambda_w,ghout$points[xx,1],ghout$points[xx,2],loglik=loglik,incl_rho=incl_rho)
x_s=ghout$points[xx,1]
x_w=ghout$points[xx,2]
if(x_s>x_w){
if(loglik){
return(-Inf)
}else{
return(0)
}
}
x_s>x_w
!is.null(nrow(mat)) && nrow(mat)>0
t1=JointLikSum_C(mat,x_s,x_w,lambda_s,lambda_w,mu_s,mu_w,loglik)
t1
loglik
t1=1
nrow(mat)
i=1
IndLik(mat[i,1],mat[i,2]-mat[i,1],x_s,x_w,lambda_s,lambda_w,mu_s,mu_w)
i=2
IndLik(mat[i,1],mat[i,2]-mat[i,1],x_s,x_w,lambda_s,lambda_w,mu_s,mu_w)
i=1
t_init=mat[i,1]
wt=mat[i,2]-mat[i,1]
xs=x_s
xw=x_w
t_init+wt>mu_s+24
t_init<xs
t_init<xs
t_init+wt>mu_s+24
t_init<xs
t_init<xw
denom=1-exp(-lambda_s*(xw-t_init))+exp(-lambda_w*(xw-t_init))-exp(-lambda_w*(mu_s+24-t_init))+(1/(1-exp(-lambda_s*24)))*(exp(-lambda_s*(mu_s+24-t_init))-exp(-lambda_s*(mu_w+24-t_init)))+(1/(1-exp(-lambda_w*24)))*(exp(-lambda_s*(mu_w+24-t_init))-exp(-lambda_w*(mu_w+48-t_init)))
denom
lambda_s
xw-t_init
exp(-lambda_s*(xw-t_init))
1-exp(-lambda_s*(xw-t_init))
exp(-lambda_w*(xw-t_init))
exp(-lambda_w*(mu_s+24-t_init))
(1/(1-exp(-lambda_s*24)))
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
init_pars4=InitialParameters(dat,anchor_t)
InitialParameters = function(mat_mod,anchor_t){
MIN_LAMBDA = .00001 # smallest value lambda can be
itrvl_len_v = seq(6,9,.5)
out_ls=list()
ratio_v = rep(NA,length(itrvl_len_v))
# find mu_s0, mu_w0
for(j in 1:length(itrvl_len_v)){
itrvl_len=itrvl_len_v[j]
start_vals=seq(0,24-itrvl_len,.25)
frac_vals = rep(NA,length(start_vals))
for(i in 1:length(start_vals)){
frac_vals[i]=length(intersect(which(mat_mod[,1]>anchor_t+start_vals[i]),which(mat_mod[,1]<anchor_t+start_vals[i]+itrvl_len)))/nrow(mat_mod)
}
mu_s0=start_vals[order(frac_vals)[1]]+anchor_t
mu_w0=mu_s0+itrvl_len
# find rate during average sleep and average waking interval
ndays= length(unique(mat_mod[,3]))
lambda_s0=max(c((min(frac_vals)*nrow(mat_mod)/ndays)/itrvl_len,MIN_LAMBDA))
lambda_w0=max(c(((1-min(frac_vals))*nrow(mat_mod)/ndays)/(24-itrvl_len),MIN_LAMBDA))
out_ls[[j]]=list(mu_s0,mu_w0,lambda_s0,lambda_w0)
ratio_v[j]=lambda_s0/lambda_w0
}
return(unlist(out_ls[[order(ratio_v)[1]]]))
}
mle.out=FindParamMLEs(outmat_mod,anchor_t)
outmat_mod
mat
outmat_mod=mat
mle.out=FindParamMLEs(outmat_mod,anchor_t)
dat
outmat_mod=dat
mle.out=FindParamMLEs(outmat_mod,anchor_t)
outmat_mod
dat
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
if(is.null(init_par)){
cat("Identifying good initial model parameters...\n")
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
init_par = GridSearchInitPars(dat,anchor_t,labels,ls_ids,mu_s0,mu_w0,lambda_s0,lambda_w0,incl_rho)
init_par[5]=0 # start with rho=0
}
init_par=NULL
if(is.null(init_par)){
cat("Identifying good initial model parameters...\n")
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
init_par = GridSearchInitPars(dat,anchor_t,labels,ls_ids,mu_s0,mu_w0,lambda_s0,lambda_w0,incl_rho)
init_par[5]=0 # start with rho=0
}
init_par
cur_par=init_par
prev_par=cur_par
cat("Numerical optimization (using optim) until convergence (maxiter=",maxiter,"):\n")
for(i in 1:maxiter){
g1=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,par_v[1],par_v[2],cur_par[3],cur_par[4],cur_par[5],par_v[3],par_v[4],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(par_v[2]-par_v[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out1=optim(par=cur_par[c(1,2,6,7)],g1,control=list(maxit=1000))
cur_par[c(1,2,6,7)]=optim.out1$par
if(incl_rho){
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],cur_par[5],cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
if(i==1){
cursleepest = GetIndSleepEstimates(dat,cur_par)
wt1=min(c(1,1-(30-nrow(cursleepest))/30))
cur_par[5]= max(0,wt1*cor(cursleepest[,1:2])[1,2])
}
}else{
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],0,cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
}
cat("Iter ",i,": mu_s =",cur_par[1],"; mu_w =",cur_par[2],"; sd_s =",cur_par[3],"; sd_w =",cur_par[4],"; rho =",cur_par[5],"; lambda_s =",cur_par[6],"; lambda_w =",cur_par[7],"\n")
if(sum((prev_par-cur_par)^2)<tol){
break
}else{
prev_par=cur_par
}
}
cursleepest
nrow(cursleepest)
wt1
for(i in 1:maxiter){
g1=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,par_v[1],par_v[2],cur_par[3],cur_par[4],cur_par[5],par_v[3],par_v[4],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(par_v[2]-par_v[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out1=optim(par=cur_par[c(1,2,6,7)],g1,control=list(maxit=1000))
cur_par[c(1,2,6,7)]=optim.out1$par
if(incl_rho){
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],cur_par[5],cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
if(i==1){
cursleepest = GetIndSleepEstimates(dat,cur_par)
wt1=min(c(1,1-(30-nrow(cursleepest))/30))
if(nrow(cursleepest)<3){
cur_par[5]=0
}else{
cur_par[5]= max(0,wt1*cor(cursleepest[,1:2])[1,2])
}
}
}else{
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],0,cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
}
cat("Iter ",i,": mu_s =",cur_par[1],"; mu_w =",cur_par[2],"; sd_s =",cur_par[3],"; sd_w =",cur_par[4],"; rho =",cur_par[5],"; lambda_s =",cur_par[6],"; lambda_w =",cur_par[7],"\n")
if(sum((prev_par-cur_par)^2)<tol){
break
}else{
prev_par=cur_par
}
}
mle.out=FindParamMLEs(outmat_mod,anchor_t)
FindParamMLEs = function(dat,anchor_t,incl_rho=TRUE,maxiter=20,init_par=NULL,tol=.0001){
labels=unique(dat[,3])
ls_ids = list()
for(i in 1:length(labels)){
ls_ids[[i]]=which(dat[,3]==i)
}
if(is.null(init_par)){
cat("Identifying good initial model parameters...\n")
init_pars4=InitialParameters(dat,anchor_t)
mu_s0=init_pars4[1]
mu_w0=init_pars4[2]
lambda_s0=init_pars4[3]
lambda_w0=init_pars4[4]
init_par = GridSearchInitPars(dat,anchor_t,labels,ls_ids,mu_s0,mu_w0,lambda_s0,lambda_w0,incl_rho)
init_par[5]=0 # start with rho=0
}
cur_par=init_par
prev_par=cur_par
cat("Numerical optimization (using optim) until convergence (maxiter=",maxiter,"):\n")
for(i in 1:maxiter){
g1=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,par_v[1],par_v[2],cur_par[3],cur_par[4],cur_par[5],par_v[3],par_v[4],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(par_v[2]-par_v[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out1=optim(par=cur_par[c(1,2,6,7)],g1,control=list(maxit=1000))
cur_par[c(1,2,6,7)]=optim.out1$par
if(incl_rho){
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],cur_par[5],cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
if(i==1){
cursleepest = GetIndSleepEstimates(dat,cur_par)
wt1=min(c(1,1-(30-nrow(cursleepest))/30))
if(nrow(cursleepest)<3){
cur_par[5]=0
}else{
cur_par[5]= max(0,wt1*cor(cursleepest[,1:2])[1,2])
}
}
}else{
g2=function(par_v){
liktot=0
for(i in 1:length(labels)){
mat=dat[ls_ids[[i]],1:2]
liktot=liktot-log(MargLik(mat,cur_par[1],cur_par[2],par_v[1],par_v[2],0,cur_par[6],cur_par[7],incl_rho))
}
liktot=liktot-length(labels)*log(dnorm(abs(cur_par[2]-cur_par[1]),mean=POP_AVG_DUR,sd=POP_SD_DUR))
return(liktot)
}
optim.out2=optim(par=cur_par[c(3,4)],g2,control=list(maxit=1000))
cur_par[c(3,4)]=optim.out2$par
}
cat("Iter ",i,": mu_s =",cur_par[1],"; mu_w =",cur_par[2],"; sd_s =",cur_par[3],"; sd_w =",cur_par[4],"; rho =",cur_par[5],"; lambda_s =",cur_par[6],"; lambda_w =",cur_par[7],"\n")
if(sum((prev_par-cur_par)^2)<tol){
break
}else{
prev_par=cur_par
}
}
return(cur_par)
}
mle.out=FindParamMLEs(outmat_mod,anchor_t)
outmat_mod
## perform quadrature of multivariate normal
## compute Gauss-Hermite quadrature points and weights
## for a one-dimensional integral.
## points -- number of points
## interlim -- maximum number of Newton-Raphson iterations
library(Rcpp)
library(RcppArmadillo)
library(mvtnorm)
sourceCpp("C:/Users/Ian/Dropbox/SleepScreenOnOff/SleepEstimation/LSE_fast.cpp")
